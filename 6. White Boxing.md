# Web Applications 
## php
### escapeshellcmd
- prevents command injection
- doesn't prevent parameter injection -> see what command gets executed, can you make it useful?
- E.g. if `nc` is executed in the back-end, you can append `-e /bin/bash` to have a shell
### exec
Directly executes on the machine
## Python

### Pickle
- `cPickle.loads() / pickle.loads()` -> RCE:`cos\nsystem\n(S'[COMMAND]'\ntR.'\ntR."`

# Reverse Engeneering
## .exe & .dll
Every executable `.exe`, will have to call a DLL, a dinamically Linked Library, which is on the disk. They contain the functions that are being called by the executable. 

Given an executable, to understand which DLL it is linked to, monitor the process with`ProcMon64` from [SysInternals](https://learn.microsoft.com/en-gb/sysinternals/downloads/procmon).

Use `ilspycmd` on Linux to read the source code, or [dnSpy](https://github.com/0xd4d/dnSpy) on Windows, if you also need to debug.

### From Linux
1. `ilspycmd` (On Kali): is NET **decompiler**, it takes compiled .NET binaries and converts them back into readable C# source code.
	- Usually System and microsoft are not interesting:
		```bash
		ilspycmd --nested-directories -p -o src [EXE/DLL]
		```
2. go in the `src` directory and grep for interesting strings to find interesting files
3. C# online compiler
### From Windows
#### x64dbg

- To avoid going through any `dll` files, navigate to `Options` -> `Preferences`, uncheck everything except `Exit Breakpoint`

-  right click inside the `CPU` view and `Follow in Memory Map`

- Check `MAP` types files for credentials &rarr; double click, check if interesting &rarr;  right-click on the address and select `Dump Memory to File`

  ```cmd
  .\strings64.exe [FILE]
  ```

#### Thick Clients 

Applications that are installed locally on our computers, thus they do not require internet access to run.

Monitor the process with`ProcMon64` from [SysInternals](https://learn.microsoft.com/en-gb/sysinternals/downloads/procmon), look for generated files

- Run `strings64` on it
- `ProcMon64` from [SysInternals](https://learn.microsoft.com/en-gb/sysinternals/downloads/procmon) and monitoring the process after running it on the terminal
  - If some files are created, change the permissions of the folder to disallow file deletions &rarr; Look at the content
  - Check .bat files, change them (e.g. if they delete somthing)
- inspect `.exe` with `x64dbg` and look for memory dumps &rarr; run `strings`
- Use `de4dot` for `.NET` file as deobfuscator and depacker &rarr;Â read the source code by dragging and dropping it onto the `DnSpy` executable

Exploiting: https://0xdf.gitlab.io/2020/08/08/htb-fatty.html
## .elf 
- `ghidra` (used by NSA so it is D O P E)
- online ghidra: https://dogbolt.org/
- `ltrace`: native Linux -> gives every function call and executes it
Process:
1. Find the main function
2. Check for vulnerable functions

ELF files is the format of binaries with .so libraries, which are in the momory of the process. It can connect to services, and are interesting even if they don't have privileges (sudo, suid). They are usually found:

- `/opt`
- `/usr/share`
- `/`
- `/home/[USER]`

-  Examine with [PEDA](https://github.com/longld/peda) Debugger
	  ```bash
	  gdb [BINARY]
	  # Return every function and their address, exclude everything that starts with _, frame_dummy, register, deregister.
	  gdb-peda$ info functions
	  # Run the program
	  gdb-peda$ run
	  # Disassemble the function, start with main
	  gdb-peda$ disas [FUNCTION]
	  ```

- Check for calls to function, e.g. 

  `call   0x5555555551b0 <SQLDriverConnect@plt>`

  - **The name of the function** is what is inside `<>`, without `@plt`.  The presence of `@plt` indicates that the function is called by a library.

  - **The arguments of the functions** are stored before the call:

    - `%*di`: 1st arg

    - `%*si`: 2st arg

    - `%*dx`: 3rd arg
    - `%*cx`: 4th arg

  - **The value of an argument,** is either an integer or a string.
    - Integers are stored with a dollar followed by its the actual value (in exadecimal)
    - Strings are visualized in white on the right-most column, and are preceded by an `#`. To get the value run: `x/s [VALUE WITHOUT #]`

- Add a breakpoint after a function is called
  ```bash
  gdb-peda$ b [NAME OF THE FUNCTION]
  # List breakpoints
  gdb-peda$ i b
  # Delete brakpoint
  gdb-peda$ d [NUM OF BREAKPOINT]
  ```

- Run the program again and see if you can get credentials.

  To have better redeability, since the CPU will be halted with a breakpoint, and you can check its status right before the call of the function with
  ```bash
  # Run until breakpoint
  gdb-peda$ r
  # check status of CPU
  gdb-peda$ i r
  # Continue after the breakpoint
  gdb-peda$ c
  # Jumo only to the next assembly instruction
  gdb-peda$ nexti
  ```

  and check its arguments.

- Change the value of an argument &rarr; exploit (e.g. SQL injection)
  ```bash
  gdb-peda$ set $[REGISTER]=0x[EX_VALUE] 
  ```

### Signing elf binary
```bash
cd ~/TOOLS/linux-elf-binary-signer
#Create a C payload 
gcc payload.c -o payload
./elf-sign sha256 key.pem key.pem payload payload_signed
```
## .jar files 
`jadx-gui` &rarr; open the file in the GUI -> Source code -> look at main
- Search for `password` -> `Load all` -> `Limit to package:` main

## .apk file 
unzip -> decompile what you find (hacktricks)